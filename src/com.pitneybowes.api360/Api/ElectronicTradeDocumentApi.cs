// <auto-generated>
/*
 * Shipping APIs
 *
 * ### Introduction  The Shipping APIs include a variety of operations that allow users to manage and track their shipping requests.   Some of the key API operations available in the Shipping API includes: ### Shipment API  | Operation      | Description | | - -- -- -- -- -- | - -- -- -- -- -- |  | Get Carriers    | The operation fetches all onboarded carriers. Typically, user will use this service to get list of onboarded carriers and supported properties for those carriers. |  | Get Countries | The operation fetches list of supported destination countries for a provided carrier and origin country. |  | Get Services | The operation fetches a list of supported services for a carrier with respect to specific origin and destination country. |  | Get ParcelTypes| The operation fetches ParcelTypes based on carrier, origin, and destination country. |  | Get Special Services| The operation fetches Special Services for a given carrier, service, origin, and destination country. |  | Get Carrier Accounts| The operation retrieves onboarded Carriers with their Carrier Account Ids which uniquely identify multiple accounts of same carrier. |  | Rate Shop and Get Single Rate| This API contains 2 operations, rate shop and single rate. Rate shop will fetch rates for all carrier services based on the given addresses (From and To), weight, and dimension for given parcelType. Single rate will get rate for specific service and special service (if requested) based on the given addresses (From and To), weight, and dimension, parcelType and serviceId with or without specialServices. Single rate will be used to rate a shipment before creating it. |  | Create Shipment| The operation creates a new Shipment or Shipment Label. This is for both Domestic and International. | | Get All Shipments| The operation fetches all created Shipments. |  | Get Shipment by Id| Retrieves single shipment using Shipment Id. |  | Reprint Shipment| The operation reprints Shipment by the shipmentId. It retrieves an existing shipping label to reprint. The API sends the shipmentId returned by the original Created Shipment request. Use this only if the shipping label in the ‘Create Shipment’ response is missing or lost. |  | Cancel Shipment| The operation cancels previously created shipment. |  
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using com.pitneybowes.api360.Client;
using com.pitneybowes.api360.Model;
using System.Diagnostics.CodeAnalysis;

namespace com.pitneybowes.api360.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IElectronicTradeDocumentApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ElectronicTradeDocumentApiEvents Events { get; }

        /// <summary>
        /// Upload Electronic Trade Document
        /// </summary>
        /// <remarks>
        /// Electronic Trade Documents Upload API is an international shipping document upload solution that simplifies global shipping needs and allows you to electronically upload customs documentation required for international shipments.  You can submit most of your trade documents electronically relieving yourself from printing or attaching trade documents with the shipment. &lt;br/&gt; This API simplifies and accelerates customs clearance by replacing physical paperwork with electronic documentation.&lt;br/&gt; The customs and other agencies receive electronically sent documents faster than paper copies attached with your shipment. The customs clearance process is also optimized as capturing and sharing of critical trade information is done at earlier stages of shipping.  &gt; Note: - In certain scenarios, the originals of specific international documents still need to be attached to the package.  - For smooth customs clearance and to avoid delays, ensure that the documents are visually clear and not distorted in any way.  **How the Workflow Operates**&lt;br/&gt;  **Step 1: Submit Electronic Trade Document Metadata**&lt;br/&gt;  Initiate the process by making a POST request to the ETD Upload API with the document metadata (e.g., file name, document type, and content type).&lt;br/&gt; In response, the system returns:&lt;br/&gt; - A pre-signed S3 upload URL (url)&lt;br/&gt; - A fileName&lt;br/&gt; - A relative &#x60;s3FileId&#x60; used to reference the uploaded document later&lt;br/&gt;  **Step 2: Upload the Document File**&lt;br/&gt;  After receiving the response, you must perform a separate HTTP PUT request to the provided [url](https://docs.shipping360.pitneybowes.com/openapi/shipping/operation/uploadETD/#!c&#x3D;200&amp;path&#x3D;url&amp;t&#x3D;response).&lt;br/&gt;  - This request must upload the binary content of the file (e.g., PDF or image)&lt;br/&gt;  - Upload the same file whose metadata was submitted in step-1 &lt;br/&gt;  **Step 3: Reference the Document in Shipment Creation**&lt;br/&gt;  Once the ETD uploaded successfully, the document is stored in the S3 bucket.&lt;br/&gt;  - Once uploaded, the document is stored in the S3 bucket and can later be referenced via the &#x60;s3FileId&#x60; in [Create International Shipment API](https://docs.shipping360.pitneybowes.com/openapi/shipping/operation/createShipment/#!path&#x3D;1/customs/customsDocuments&amp;t&#x3D;request)  under &#x60;customsDocuments&#x60; object. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadETDRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadETDApiResponse"/>&gt;</returns>
        Task<IUploadETDApiResponse> UploadETDAsync(UploadETDRequest uploadETDRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Upload Electronic Trade Document
        /// </summary>
        /// <remarks>
        /// Electronic Trade Documents Upload API is an international shipping document upload solution that simplifies global shipping needs and allows you to electronically upload customs documentation required for international shipments.  You can submit most of your trade documents electronically relieving yourself from printing or attaching trade documents with the shipment. &lt;br/&gt; This API simplifies and accelerates customs clearance by replacing physical paperwork with electronic documentation.&lt;br/&gt; The customs and other agencies receive electronically sent documents faster than paper copies attached with your shipment. The customs clearance process is also optimized as capturing and sharing of critical trade information is done at earlier stages of shipping.  &gt; Note: - In certain scenarios, the originals of specific international documents still need to be attached to the package.  - For smooth customs clearance and to avoid delays, ensure that the documents are visually clear and not distorted in any way.  **How the Workflow Operates**&lt;br/&gt;  **Step 1: Submit Electronic Trade Document Metadata**&lt;br/&gt;  Initiate the process by making a POST request to the ETD Upload API with the document metadata (e.g., file name, document type, and content type).&lt;br/&gt; In response, the system returns:&lt;br/&gt; - A pre-signed S3 upload URL (url)&lt;br/&gt; - A fileName&lt;br/&gt; - A relative &#x60;s3FileId&#x60; used to reference the uploaded document later&lt;br/&gt;  **Step 2: Upload the Document File**&lt;br/&gt;  After receiving the response, you must perform a separate HTTP PUT request to the provided [url](https://docs.shipping360.pitneybowes.com/openapi/shipping/operation/uploadETD/#!c&#x3D;200&amp;path&#x3D;url&amp;t&#x3D;response).&lt;br/&gt;  - This request must upload the binary content of the file (e.g., PDF or image)&lt;br/&gt;  - Upload the same file whose metadata was submitted in step-1 &lt;br/&gt;  **Step 3: Reference the Document in Shipment Creation**&lt;br/&gt;  Once the ETD uploaded successfully, the document is stored in the S3 bucket.&lt;br/&gt;  - Once uploaded, the document is stored in the S3 bucket and can later be referenced via the &#x60;s3FileId&#x60; in [Create International Shipment API](https://docs.shipping360.pitneybowes.com/openapi/shipping/operation/createShipment/#!path&#x3D;1/customs/customsDocuments&amp;t&#x3D;request)  under &#x60;customsDocuments&#x60; object. 
        /// </remarks>
        /// <param name="uploadETDRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadETDApiResponse"/>&gt;</returns>
        Task<IUploadETDApiResponse> UploadETDOrDefaultAsync(UploadETDRequest uploadETDRequest, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IUploadETDApiResponse"/>
    /// </summary>
    public interface IUploadETDApiResponse : com.pitneybowes.api360.Client.IApiResponse, IOk<com.pitneybowes.api360.Model.UploadETD200Response>, IBadRequest<List<InvalidErrorsInner>>, IUnauthorized<com.pitneybowes.api360.Model.UnauthorizedError>, INotFound<List<NotFoundErrorsInner>>, IInternalServerError<com.pitneybowes.api360.Model.ServerError>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ElectronicTradeDocumentApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnUploadETD;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorUploadETD;

        internal void ExecuteOnUploadETD(ElectronicTradeDocumentApi.UploadETDApiResponse apiResponse)
        {
            OnUploadETD?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUploadETD(Exception exception)
        {
            OnErrorUploadETD?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ElectronicTradeDocumentApi : IElectronicTradeDocumentApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ElectronicTradeDocumentApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ElectronicTradeDocumentApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BasicTokenProvider"/>
        /// </summary>
        public TokenProvider<BasicToken> BasicTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ElectronicTradeDocumentApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ElectronicTradeDocumentApi(ILogger<ElectronicTradeDocumentApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ElectronicTradeDocumentApiEvents electronicTradeDocumentApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<BasicToken> basicTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ElectronicTradeDocumentApi>();
            HttpClient = httpClient;
            Events = electronicTradeDocumentApiEvents;
            BearerTokenProvider = bearerTokenProvider;
            BasicTokenProvider = basicTokenProvider;
        }

        partial void FormatUploadETD(UploadETDRequest uploadETDRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="uploadETDRequest"></param>
        /// <returns></returns>
        private void ValidateUploadETD(UploadETDRequest uploadETDRequest)
        {
            if (uploadETDRequest == null)
                throw new ArgumentNullException(nameof(uploadETDRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="uploadETDRequest"></param>
        private void AfterUploadETDDefaultImplementation(IUploadETDApiResponse apiResponseLocalVar, UploadETDRequest uploadETDRequest)
        {
            bool suppressDefaultLog = false;
            AfterUploadETD(ref suppressDefaultLog, apiResponseLocalVar, uploadETDRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="uploadETDRequest"></param>
        partial void AfterUploadETD(ref bool suppressDefaultLog, IUploadETDApiResponse apiResponseLocalVar, UploadETDRequest uploadETDRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="uploadETDRequest"></param>
        private void OnErrorUploadETDDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, UploadETDRequest uploadETDRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUploadETD(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, uploadETDRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="uploadETDRequest"></param>
        partial void OnErrorUploadETD(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, UploadETDRequest uploadETDRequest);

        /// <summary>
        /// Upload Electronic Trade Document Electronic Trade Documents Upload API is an international shipping document upload solution that simplifies global shipping needs and allows you to electronically upload customs documentation required for international shipments.  You can submit most of your trade documents electronically relieving yourself from printing or attaching trade documents with the shipment. &lt;br/&gt; This API simplifies and accelerates customs clearance by replacing physical paperwork with electronic documentation.&lt;br/&gt; The customs and other agencies receive electronically sent documents faster than paper copies attached with your shipment. The customs clearance process is also optimized as capturing and sharing of critical trade information is done at earlier stages of shipping.  &gt; Note: - In certain scenarios, the originals of specific international documents still need to be attached to the package.  - For smooth customs clearance and to avoid delays, ensure that the documents are visually clear and not distorted in any way.  **How the Workflow Operates**&lt;br/&gt;  **Step 1: Submit Electronic Trade Document Metadata**&lt;br/&gt;  Initiate the process by making a POST request to the ETD Upload API with the document metadata (e.g., file name, document type, and content type).&lt;br/&gt; In response, the system returns:&lt;br/&gt; - A pre-signed S3 upload URL (url)&lt;br/&gt; - A fileName&lt;br/&gt; - A relative &#x60;s3FileId&#x60; used to reference the uploaded document later&lt;br/&gt;  **Step 2: Upload the Document File**&lt;br/&gt;  After receiving the response, you must perform a separate HTTP PUT request to the provided [url](https://docs.shipping360.pitneybowes.com/openapi/shipping/operation/uploadETD/#!c&#x3D;200&amp;path&#x3D;url&amp;t&#x3D;response).&lt;br/&gt;  - This request must upload the binary content of the file (e.g., PDF or image)&lt;br/&gt;  - Upload the same file whose metadata was submitted in step-1 &lt;br/&gt;  **Step 3: Reference the Document in Shipment Creation**&lt;br/&gt;  Once the ETD uploaded successfully, the document is stored in the S3 bucket.&lt;br/&gt;  - Once uploaded, the document is stored in the S3 bucket and can later be referenced via the &#x60;s3FileId&#x60; in [Create International Shipment API](https://docs.shipping360.pitneybowes.com/openapi/shipping/operation/createShipment/#!path&#x3D;1/customs/customsDocuments&amp;t&#x3D;request)  under &#x60;customsDocuments&#x60; object. 
        /// </summary>
        /// <param name="uploadETDRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadETDApiResponse"/>&gt;</returns>
        public async Task<IUploadETDApiResponse> UploadETDOrDefaultAsync(UploadETDRequest uploadETDRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UploadETDAsync(uploadETDRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Upload Electronic Trade Document Electronic Trade Documents Upload API is an international shipping document upload solution that simplifies global shipping needs and allows you to electronically upload customs documentation required for international shipments.  You can submit most of your trade documents electronically relieving yourself from printing or attaching trade documents with the shipment. &lt;br/&gt; This API simplifies and accelerates customs clearance by replacing physical paperwork with electronic documentation.&lt;br/&gt; The customs and other agencies receive electronically sent documents faster than paper copies attached with your shipment. The customs clearance process is also optimized as capturing and sharing of critical trade information is done at earlier stages of shipping.  &gt; Note: - In certain scenarios, the originals of specific international documents still need to be attached to the package.  - For smooth customs clearance and to avoid delays, ensure that the documents are visually clear and not distorted in any way.  **How the Workflow Operates**&lt;br/&gt;  **Step 1: Submit Electronic Trade Document Metadata**&lt;br/&gt;  Initiate the process by making a POST request to the ETD Upload API with the document metadata (e.g., file name, document type, and content type).&lt;br/&gt; In response, the system returns:&lt;br/&gt; - A pre-signed S3 upload URL (url)&lt;br/&gt; - A fileName&lt;br/&gt; - A relative &#x60;s3FileId&#x60; used to reference the uploaded document later&lt;br/&gt;  **Step 2: Upload the Document File**&lt;br/&gt;  After receiving the response, you must perform a separate HTTP PUT request to the provided [url](https://docs.shipping360.pitneybowes.com/openapi/shipping/operation/uploadETD/#!c&#x3D;200&amp;path&#x3D;url&amp;t&#x3D;response).&lt;br/&gt;  - This request must upload the binary content of the file (e.g., PDF or image)&lt;br/&gt;  - Upload the same file whose metadata was submitted in step-1 &lt;br/&gt;  **Step 3: Reference the Document in Shipment Creation**&lt;br/&gt;  Once the ETD uploaded successfully, the document is stored in the S3 bucket.&lt;br/&gt;  - Once uploaded, the document is stored in the S3 bucket and can later be referenced via the &#x60;s3FileId&#x60; in [Create International Shipment API](https://docs.shipping360.pitneybowes.com/openapi/shipping/operation/createShipment/#!path&#x3D;1/customs/customsDocuments&amp;t&#x3D;request)  under &#x60;customsDocuments&#x60; object. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadETDRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUploadETDApiResponse"/>&gt;</returns>
        public async Task<IUploadETDApiResponse> UploadETDAsync(UploadETDRequest uploadETDRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUploadETD(uploadETDRequest);

                FormatUploadETD(uploadETDRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/importUrl"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/importUrl");

                    httpRequestMessageLocalVar.Content = (uploadETDRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(uploadETDRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));
                    httpRequestMessageLocalVar.Method = new HttpMethod("POST");

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync().ConfigureAwait(false);

                        ILogger<UploadETDApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UploadETDApiResponse>();

                        UploadETDApiResponse apiResponseLocalVar = new UploadETDApiResponse(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/importUrl", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUploadETDDefaultImplementation(apiResponseLocalVar, uploadETDRequest);

                        Events.ExecuteOnUploadETD(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUploadETDDefaultImplementation(e, "/api/v1/importUrl", uriBuilderLocalVar.Path, uploadETDRequest);
                Events.ExecuteOnErrorUploadETD(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UploadETDApiResponse"/>
        /// </summary>
        public partial class UploadETDApiResponse : com.pitneybowes.api360.Client.ApiResponse, IUploadETDApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UploadETDApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UploadETDApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UploadETDApiResponse(ILogger<UploadETDApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public com.pitneybowes.api360.Model.UploadETD200Response Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<com.pitneybowes.api360.Model.UploadETD200Response>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk(out com.pitneybowes.api360.Model.UploadETD200Response result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public List<InvalidErrorsInner> BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InvalidErrorsInner>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest(out List<InvalidErrorsInner> result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public com.pitneybowes.api360.Model.UnauthorizedError Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<com.pitneybowes.api360.Model.UnauthorizedError>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized(out com.pitneybowes.api360.Model.UnauthorizedError result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public List<NotFoundErrorsInner> NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<List<NotFoundErrorsInner>>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound(out List<NotFoundErrorsInner> result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public com.pitneybowes.api360.Model.ServerError InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<com.pitneybowes.api360.Model.ServerError>(RawContent, _jsonSerializerOptions)
                    : default;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError(out com.pitneybowes.api360.Model.ServerError result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
